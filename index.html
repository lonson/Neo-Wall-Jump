<!DOCTYPE html>
<html lang="pt-BR">
    <head>
      <title>Destroy the Evil Tower</title>

        <meta charset="utf-8">
        <meta name="keywords" content=""/>
        <meta name="description" content=""/>

        <script src="pixi.js"></script>
        <script src="p2.js"></script>

        <style type="text/css" media="screen">
          body {
            margin: 0px;
          }
        </style>


        <!--[if IE]>
          <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body>
      <script type="text/javascript" language="javascript" charset="utf-8">
      //<![CDATA[
        let app = new PIXI.Application({
          forceCanvas: true
        });

        let type = "WebGL"
        if(!PIXI.utils.isWebGLSupported()){
          type = "canvas"
        }

        PIXI.utils.sayHello(type)


        app.renderer.view.style.position = "absolute";
        app.renderer.view.style.display = "block";
        app.renderer.autoResize = true;
        app.renderer.resize(window.innerWidth, window.innerHeight);
        // debugger
        app.stage.position.y = app.renderer.height / app.renderer.resolution;
        app.stage.scale.y = -1;

        //Add the canvas that Pixi automatically created for you to the HTML document
        document.body.appendChild(app.view);

        const renderCharacter = (x, y, width, height) => {
          let rectangle = new PIXI.Graphics()
          rectangle.beginFill(0x66CCFF)
          rectangle.lineStyle(4, 0xFF3300, 1)
          
          const lowerLeftX = x - width/2
          const lowerLeftY = y - height/2

          rectangle.drawRect(lowerLeftX, lowerLeftY, width, height)
          rectangle.endFill()
          app.stage.addChild(rectangle)
        }

        const renderWall = (x, y, width, height) => {
          let rectangle = new PIXI.Graphics()
          rectangle.beginFill(0x00FF00)
          // rectangle.lineStyle(4, 0xFF3300, 1)

          const lowerLeftX = x - width/2
          const lowerLeftY = y - height/2

          rectangle.drawRect(lowerLeftX, lowerLeftY, width, height)
          rectangle.endFill()
          app.stage.addChild(rectangle)
        }

        const moveObjects = () => {
          const prevPosition = characterBody.position

          if (keyPresses[37]) prevPosition[0] -= 1  // left
          if (keyPresses[39]) prevPosition[0] += 1  // right
          if (keyPresses[38]) prevPosition[1] += 10  // up
              
          characterBody.position = prevPosition
        }

        const renderObjects = () => {
          console.log("position: " + character.body.position[1])
          renderCharacter(character.body.position[0], character.body.position[1], character.width, character.height)

          for (var i = 0; i < walls.length; i++) {
            let wall = walls[i]
            renderWall(wall.body.position[0], wall.body.position[1], wall.width, wall.height)
          }
        }

        const walls = []

        const createWall = (x, y) => {
          // Create an infinite ground plane body
          var body = new p2.Body({
              mass: 0, // Setting mass to 0 makes it static,
              position: [x,y]
          });
          var shape = new p2.Box({ width: 150, height: 1500})
          body.addShape(shape);
          world.addBody(body);

          walls.push(shape)
        }

        const runWorldPhysics = () => {
            // To animate the bodies, we must step the world forward in time, using a fixed time step size.
          // The World will run substeps and interpolate automatically for us, to get smooth animation.
          var fixedTimeStep = 1 / 60; // seconds
          var maxSubSteps = 10; // Max sub steps to catch up with the wall clock
          var lastTime;

          // Animation loop
          function animate(time){
              requestAnimationFrame(animate);

              // const canvas = document.getElementsByTagName("canvas")[0].getContext("2d")

              // if (typeof canvas !== "undefined") {
              //   // clear previous canvas
              //   canvas.width  = window.innerWidth;
              //   canvas.height = window.innerHeight;
              //   console.log("widhtl; " + canvas.width)
              //   // canvas.clearRect(0, 0, canvas.width, canvas.height)
              // }

              if (typeof app !== "undefined") {
                for (var i = app.stage.children.length - 1; i >= 0; i--) {  
                  app.stage.removeChild(app.stage.children[i])
                }
              }



              // Compute elapsed time since last render frame
              var deltaTime = lastTime ? (time - lastTime) / 1000 : 0;

              // Move bodies forward in time
              world.step(fixedTimeStep, deltaTime, maxSubSteps);


              // move objects based on user input
              moveObjects()
              renderObjects()

              lastTime = time;
          }

          // Start the animation loop
          requestAnimationFrame(animate);
        }

        var world = new p2.World({
            gravity: [0, -1000]
        })

        world.defaultContactMaterial.friction = 0.9
        world.defaultContactMaterial.restitution = 0.5


        var characterBody = new p2.Body({
            position: [150, 250],
            mass: 1,
            damping: 0.999,
            inertia: 0.4
        });

        // Add a circle shape to the body
        var character = new p2.Box({ width: 100, height: 100 });
        characterBody.addShape(character);

        window.c = characterBody

        world.addBody(characterBody);

        // Create an infinite ground plane body
        var groundBody = new p2.Body({
            mass: 0 // Setting mass to 0 makes it static
        });
        var groundShape = new p2.Plane();
        groundBody.addShape(groundShape);
        world.addBody(groundBody);

        createWall(30,0)
        createWall(window.innerWidth - 30, 0)

        runWorldPhysics()

        window.keyPresses = {}

        document.addEventListener("keyup", (event) => {
          keyPresses[event.which] = false
        })

        document.addEventListener("keydown", (event) => {


          keyPresses[event.which] = true
        })

      //]]>
      </script>
    </body>
</html>
